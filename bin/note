#!/usr/bin/env node

const NoteManager = require('../lib/NoteManager');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');

const DATA_DIR = process.env.NOTE_DATA_DIR || path.join(__dirname, '../data');
const TIMEZONE = process.env.TZ || Intl.DateTimeFormat().resolvedOptions().timeZone;
const noteManager = new NoteManager(DATA_DIR, TIMEZONE);

const colors = {
  red: '\x1b[0;31m',
  green: '\x1b[0;32m',
  yellow: '\x1b[1;33m',
  reset: '\x1b[0m'
};

function error(msg) {
  console.error(`${colors.red}Error: ${msg}${colors.reset}`);
  process.exit(1);
}

function success(msg) {
  console.log(`${colors.green}${msg}${colors.reset}`);
}

function warning(msg) {
  console.log(`${colors.yellow}${msg}${colors.reset}`);
}

async function readStdin() {
  return new Promise((resolve, reject) => {
    let data = '';
    process.stdin.setEncoding('utf8');
    process.stdin.on('data', chunk => data += chunk);
    process.stdin.on('end', () => resolve(data));
    process.stdin.on('error', reject);
  });
}

async function getContent(arg) {
  if (arg) return arg;
  if (!process.stdin.isTTY) {
    const content = await readStdin();
    return content.trim();
  }
  return null;
}

function confirm(question) {
  return new Promise((resolve) => {
    const readline = require('readline').createInterface({
      input: process.stdin,
      output: process.stdout
    });
    readline.question(`${colors.yellow}${question} (y/N)${colors.reset} `, (answer) => {
      readline.close();
      resolve(answer.toLowerCase() === 'y');
    });
  });
}

async function cmdWrite(args) {
  const [pathArg, ...contentParts] = args;
  if (!pathArg) error('path required\nUsage: note write <path> [content]');

  const content = await getContent(contentParts.join(' '));
  if (!content) error('content required (provide as argument or via stdin)');

  await noteManager.write(pathArg, content);
  success(`Written: ${pathArg}`);
}

async function cmdNew(args) {
  const [pathArg, ...contentParts] = args;
  if (!pathArg) error('path required\nUsage: note new <path> [content]');

  const content = await getContent(contentParts.join(' '));
  if (!content) error('content required (provide as argument or via stdin)');

  try {
    await noteManager.new(pathArg, content);
    success(`Created: ${pathArg}`);
  } catch (err) {
    error(err.message);
  }
}

async function cmdAppend(args) {
  const [pathArg, ...contentParts] = args;
  if (!pathArg) error('path required\nUsage: note append <path> [content]');

  const content = await getContent(contentParts.join(' '));
  if (!content) error('content required (provide as argument or via stdin)');

  await noteManager.append(pathArg, content);
  success(`Appended to: ${pathArg}`);
}

async function cmdRead(args) {
  const [pathArg] = args;
  if (!pathArg) error('path required\nUsage: note read <path>');

  try {
    const result = await noteManager.read(pathArg);
    console.log(result.content);
  } catch (err) {
    error(err.message);
  }
}

async function cmdEdit(args) {
  const [pathArg] = args;
  if (!pathArg) error('path required\nUsage: note edit <path>');

  const fullPath = noteManager.getFullPath(pathArg);
  await noteManager.ensureDir(fullPath);

  const editor = process.env.EDITOR || 'nano';
  const child = spawn(editor, [fullPath], { stdio: 'inherit' });

  child.on('exit', (code) => {
    if (code === 0) {
      success(`Edited: ${pathArg}`);
    }
    process.exit(code);
  });
}

async function cmdRm(args) {
  const pathArg = args[0];
  const force = args.includes('-f');

  if (!pathArg) error('path required\nUsage: note rm <path> [-f]');

  if (!force) {
    const confirmed = await confirm(`Delete ${pathArg}?`);
    if (!confirmed) {
      console.log('Cancelled');
      process.exit(0);
    }
  }

  try {
    await noteManager.delete(pathArg);
    success(`Deleted: ${pathArg}`);
  } catch (err) {
    error(err.message);
  }
}

async function cmdMv(args) {
  const [from, to] = args;
  if (!from || !to) error('source and destination required\nUsage: note mv <from> <to>');

  try {
    await noteManager.move(from, to);
    success(`Moved: ${from} ‚Üí ${to}`);
  } catch (err) {
    error(err.message);
  }
}

async function cmdList(args) {
  const flat = args.includes('--flat');
  const recursive = args.includes('-r');
  const pathArg = args.find(arg => !arg.startsWith('-')) || '.';

  try {
    const result = await noteManager.list(pathArg, recursive);
    result.items.forEach(item => {
      if (flat) {
        if (item.type === 'file') {
          console.log(item.path);
        }
      } else {
        const prefix = item.type === 'dir' ? 'üìÅ ' : 'üìÑ ';
        console.log(`${prefix}${item.path}`);
      }
    });
  } catch (err) {
    error(err.message);
  }
}

async function cmdSearch(args) {
  const term = args[0];
  const listOnly = args.includes('-l');

  if (!term) error('search term required\nUsage: note search <term> [-l]');

  const result = await noteManager.search(term, listOnly);

  if (listOnly) {
    result.files.forEach(file => console.log(file));
  } else {
    result.matches.forEach(match => console.log(match));
  }
}

async function cmdQuick(args) {
  // If no args, try to read journal (pass null to quickJournal)
  // If args provided, write to journal
  let content;
  if (args.length === 0) {
    // No arguments - read today's journal
    content = null;
  } else {
    // Arguments provided - write to journal
    const argString = args.join(' ');
    content = await getContent(argString);
  }

  const result = await noteManager.quickJournal(content);

  if (content === null || content === '') {
    if (result.content) {
      console.log(result.content);
    } else {
      warning('No journal entry for today');
    }
  } else {
    success(`Added to journal: ${result.path.split('/')[1]} at ${result.time}`);
  }
}

async function cmdInteractive() {
  const { spawn } = require('child_process');
  const pathModule = require('path');

  // Check if fzf is installed
  try {
    await new Promise((resolve, reject) => {
      const check = spawn('which', ['fzf']);
      check.on('exit', code => code === 0 ? resolve() : reject());
    });
  } catch (err) {
    error('fzf is not installed. Please install it:\n  https://github.com/junegunn/fzf#installation');
  }

  let currentPath = '';

  async function searchAll() {
    // Get ALL files recursively
    const result = await noteManager.list('.', true);
    const files = result.items.filter(item => item.type === 'file');

    if (files.length === 0) {
      warning('No notes found');
      return { action: 'exit' };
    }

    return new Promise((resolve) => {
      const fzf = spawn('fzf', [
        '--prompt=Search all files > ',
        '--ansi',
        '--layout=reverse',
        '--with-nth=1',
        '--delimiter=\t',
        '--preview', 'if [ -f ' + DATA_DIR + '/{2}.md ]; then cat ' + DATA_DIR + '/{2}.md; fi',
        '--preview-window=right:60%:wrap',
        '--header=Enter: open | Esc: back to browse'
      ], { stdio: ['pipe', 'pipe', 'inherit'] });

      // Write all files
      const fzfInput = files.map(file => {
        return `üìÑ ${file.path}\t${file.path}`;
      }).join('\n');

      fzf.stdin.write(fzfInput);
      fzf.stdin.end();

      let selected = '';
      fzf.stdout.on('data', data => selected += data.toString());

      fzf.on('exit', (code) => {
        if (code === 130) {
          // User cancelled - go back to browse
          resolve({ action: 'browse' });
        } else if (code === 0 && selected.trim()) {
          const selectedLine = selected.trim();
          const [display, filePath] = selectedLine.split('\t');
          resolve({ action: 'open', path: filePath });
        } else {
          resolve({ action: 'browse' });
        }
      });
    });
  }

  async function browse(dirPath) {
    // Get directory contents (non-recursive - local only)
    const fullPath = dirPath || '.';
    const result = await noteManager.list(fullPath, false);

    const items = [];

    // Add parent directory option if not at root
    if (dirPath) {
      items.push({ type: 'parent', display: 'üìÅ ..', path: null });
    }

    // Add folders and files from current directory only
    result.items.forEach(item => {
      const itemName = pathModule.basename(item.path);
      const prefix = item.type === 'dir' ? 'üìÅ ' : 'üìÑ ';
      const display = prefix + itemName;
      items.push({
        type: item.type,
        path: item.path,
        display: display
      });
    });

    if (items.length === 0) {
      warning('Empty directory');
      return;
    }

    // Run fzf
    return new Promise((resolve) => {
      const fzf = spawn('fzf', [
        '--prompt=' + (dirPath || 'root') + ' > ',
        '--ansi',
        '--layout=reverse',
        '--with-nth=1',
        '--delimiter=\t',
        '--preview', 'if [ -f ' + DATA_DIR + '/{2}.md ]; then cat ' + DATA_DIR + '/{2}.md; elif [ -d ' + DATA_DIR + '/{2} ]; then node /app/bin/note ls {2}; fi',
        '--preview-window=right:60%:wrap',
        '--header=Enter: open/navigate | Ctrl-F: search all files | Esc: exit',
        '--bind', 'ctrl-f:execute-silent(echo __SEARCH__ > /tmp/fzf-action)+abort'
      ], { stdio: ['pipe', 'pipe', 'inherit'] });

      // Write items to fzf with tab-separated display and path
      const fzfInput = items.map(item => {
        if (item.type === 'parent') {
          return 'üìÅ ..\t';
        }
        return `${item.display}\t${item.path}`;
      }).join('\n');

      fzf.stdin.write(fzfInput);
      fzf.stdin.end();

      let selected = '';
      fzf.stdout.on('data', data => selected += data.toString());

      fzf.on('exit', (code) => {
        // Check if Ctrl-F was pressed
        let isSearch = false;
        try {
          const marker = fs.readFileSync('/tmp/fzf-action', 'utf8').trim();
          if (marker === '__SEARCH__') {
            isSearch = true;
            fs.unlinkSync('/tmp/fzf-action');
          }
        } catch (e) {
          // Marker file doesn't exist, not a search
        }

        if (isSearch) {
          resolve({ action: 'search' });
        } else if (code === 130) {
          // User cancelled with Esc
          resolve({ action: 'exit' });
        } else if (code === 0 && selected.trim()) {
          const selectedLine = selected.trim();
          const [display, itemPath] = selectedLine.split('\t');
          const selectedItem = items.find(item => item.display === display || (item.type === 'parent' && display === 'üìÅ ..'));

          if (selectedItem) {
            resolve({ action: 'select', item: selectedItem });
          } else {
            resolve({ action: 'browse', path: dirPath });
          }
        } else {
          resolve({ action: 'exit' });
        }
      });
    });
  }

  async function openFile(filePath) {
    const fullPath = noteManager.getFullPath(filePath);
    const editor = process.env.EDITOR || 'nano';

    return new Promise((resolve) => {
      const edit = spawn(editor, [fullPath], { stdio: 'inherit' });
      edit.on('exit', () => resolve());
    });
  }

  // Main browse loop
  while (true) {
    const result = await browse(currentPath);

    if (result.action === 'exit') {
      process.exit(0);
    } else if (result.action === 'search') {
      // Switch to search all files mode
      const searchResult = await searchAll();

      if (searchResult.action === 'open') {
        // Open the selected file
        await openFile(searchResult.path);
        // After editing, return to browse mode at current path
      } else if (searchResult.action === 'exit') {
        process.exit(0);
      }
      // If action is 'browse', just continue to current path
    } else if (result.action === 'select') {
      const item = result.item;

      if (item.type === 'parent') {
        // Go up one level
        const parts = currentPath.split('/').filter(p => p);
        parts.pop();
        currentPath = parts.join('/');
      } else if (item.type === 'dir') {
        // Navigate into directory
        currentPath = item.path;
      } else if (item.type === 'file') {
        // Open file in editor
        await openFile(item.path);
        // After editing, return to browser
      }
    } else {
      // Re-browse current directory
      continue;
    }
  }
}

async function cmdInstall() {
  const homeDir = process.env.HOME;
  const bashProfile = fs.existsSync(path.join(homeDir, '.bash_profile'))
    ? path.join(homeDir, '.bash_profile')
    : path.join(homeDir, '.bashrc');

  try {
    const content = fs.readFileSync(bashProfile, 'utf8');
    if (content.includes('alias note=')) {
      warning(`Alias already exists in ${bashProfile}`);
      return;
    }
  } catch (err) {
    // File doesn't exist, will be created
  }

  const aliasLine = `alias note='docker exec -it notes node /app/bin/note'`;

  fs.appendFileSync(bashProfile, `\n# Note CLI\n${aliasLine}\n`);

  success('Alias installed!');
  console.log(`Run: source ${bashProfile}`);
  console.log('Or restart your terminal');
}

function showCommands() {
  console.log(`Note CLI Commands:
  write, new, append, read, cat, edit, rm, mv, list, ls, search, -q, -i, install

Run 'note --help' for detailed usage`);
}

function showHelp() {
  console.log(`Note CLI - Markdown note management

Usage: note [command] [options]

Commands:
  write <path> [content]    Create or update a note
  new <path> [content]      Create a new note (fails if exists)
  append <path> [content]   Append content to a note
  read <path>               Read and output a note
  cat <path>                Alias for read
  edit <path>               Open note in editor (uses $EDITOR or nano)
  rm <path> [-f]            Delete a note (with confirmation unless -f)
  mv <from> <to>            Move or rename a note
  list [path]               List notes (alias: ls)
  ls [path]                 List notes
  search <term> [-l]        Search note contents (-l for filenames only)

Quick Journal:
  -q [content]              Add timestamped entry to today's journal
                           (reads today's journal if no content)

Interactive:
  -i                        Browse notes interactively with fzf (requires fzf)

Setup:
  install                   Add docker exec alias to bash profile

Notes:
  - All paths are relative to data directory
  - .md extension is added automatically if missing
  - Content can be provided as argument or piped via stdin
  - Use quotes for content with spaces

Examples:
  note write ideas/project "My new idea"
  echo "Content" | note write path/to/note
  note -q Quick thought without quotes
  note -i
  note search "docker" -l
  note ls ideas/
  note read ideas/project | grep "important"

  # Using docker exec alias (after install):
  docker exec -i notes node /app/bin/note write test "content"`);
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    showCommands();
    process.exit(0);
  }

  const command = args[0];
  const commandArgs = args.slice(1);

  try {
    switch (command) {
      case 'write':
        await cmdWrite(commandArgs);
        break;
      case 'new':
        await cmdNew(commandArgs);
        break;
      case 'append':
        await cmdAppend(commandArgs);
        break;
      case 'read':
      case 'cat':
        await cmdRead(commandArgs);
        break;
      case 'edit':
        await cmdEdit(commandArgs);
        break;
      case 'rm':
        await cmdRm(commandArgs);
        break;
      case 'mv':
        await cmdMv(commandArgs);
        break;
      case 'list':
      case 'ls':
        await cmdList(commandArgs);
        break;
      case 'search':
        await cmdSearch(commandArgs);
        break;
      case '-q':
        await cmdQuick(commandArgs);
        break;
      case '-i':
        await cmdInteractive();
        break;
      case 'install':
        await cmdInstall();
        break;
      case '--help':
      case '-h':
        showHelp();
        break;
      default:
        error(`Unknown command: ${command}`);
        showCommands();
    }
  } catch (err) {
    error(err.message);
  }
}

main();
